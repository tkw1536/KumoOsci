from matplotlib import pyplot as plt
import matplotlib.animation as animation
import networkx as nx
import numpy as np
from tqdm import tqdm

def plot_network_and_graph(kura, ts, s, layout = None, labels = False, edges = True):
    """
    Plots the network of a Kuramoto Oscilator and the solution. 
    
    Arguments:
        kura
            KuramotoOscilator() instance to plot
        ts
            Times for which the oscilator has been simulated
        s
            Solution of the KuramotoOscilator() to plot. Should have
            been generated by kura.simulate(..., ts, ....). 
        layout
            Optional. A function that given the networkx graph instance should
            return a list of node positions. By default uses 
            networkx.circular_layout. 
        labels
            Optional boolean. Set to True to enable plotting of the graph labels. 
        edges
            Optional boolean. Set to False to disable drawing of graph edges. 
    """
    
    # get ready to make the plot
    plt.subplot(212)
    colors = []
    
    for j in range(kura.N):
        # draw and store color
        c = plt.plot(ts, s[:,j], label='Oscilator %s' % (j))
        colors.append(c[0].get_color())
    
    # now plot the graph
    plt.subplot(211)
    
    # Get the graph and layout
    G = kura.graph
    
    if layout == None:
        layout = nx.circular_layout(G)
    else:
        layout = layout(G)
    
    # do the drawing
    draw_networkx_graph(G, draw_nodes = True, node_pos = layout, node_color = colors, draw_edges = edges, draw_labels = labels)

def animate_network(kura, ts, s):
    """
    Animates the network colors over time
    
    Arguments:
        kura
            KuramotoOscilator() instance to plot
        ts
            Times for which the oscilator has been simulated
        s
            Solution of the KuramotoOscilator() to plot. Should have
            been generated by kura.simulate(..., ts, ....). 
    """
    
    # extract the networkx graph and compute the layout
    G = kura.graph
    pos = nx.circular_layout(G)
    nodes = G.nodes()
    
    # number of times
    T = len(ts)
    
    # get the current axis and stuff
    fig = plt.gcf()
    ax = plt.gca()
    
    # Because no
    plt.axis('on')

    # because we dont want grids
    ax.set_axis_bgcolor('black')
    ax.grid(b=False)
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    
    def anim_update(i, ax, pbar):
        """
        Helper function called to update the animation
        
        Arguments:
            i
                Index of current frame to draw
            ax
                Axis object to update frame in
            pbar
                Progressbar handle to update
        """
        
        # reset the axis so that we can draw
        ax.clear()
        
        # compute the alphas
        alphas = s[i, :] / (2 * np.pi)
        
        # iterate and draw the nodes
        for (a, n) in zip(alphas, nodes):
            nx.draw_networkx_nodes(
                G, pos,
                nodelist=[n], alpha=a,
                node_color='yellow', node_size=800,
                ax=ax)
        
        # we have rendered the frame, so tell the frame
        pbar.update(1)
    
    
    # run the animation
    with tqdm(total=T) as pbar:
        ani = animation.FuncAnimation(fig, anim_update, frames=T, fargs=(ax, pbar))
    
    return ani

def draw_networkx_graph(G, 
    ax = None, 
    draw_nodes = True, node_pos = None, node_size = None, node_shape = None, node_color = None, node_alpha = None, node_linewidth = None, 
    draw_labels = False, label_args=None, label_kwargs=None,
    draw_edges = True, edges_args=None, edges_kwargs=None,
    draw_edge_labels = False, edge_label_args=None, edge_label_kwargs=None
):
    """
    Helper function to draw a networkx graph. 
    
    General Arguments:
    
        G
            Networkx graph to draw. 
        ax
            Optional. Draw the graph in the specified Matplotlib axes.
            
    Node Arguments:
        
        draw_nodes
            Optional boolean indicating if the nodes of the graph should be drawn. 
        node_pos
            Optional. A dictionary with nodes as keys and positions as values. Positions should be sequences of length 2. 
        node_size
            Optional. Size of nodes to draw. If omitted, defaults to 300. 
        node_shape
            Optional. Shape of nodes to draw. If omitted defaults to 'o'. 
        node_color
            Optional. Should either be a string or a list of strings indicating
            the color of nodes. Defaults to 'y' for yellow. 
        node_alpha
            Optional. Should either be a string or a list of values indicating
            the alpha values of the nodes. Defaults to 1. 
        node_linewidths
            Optional. A float or list of floats of node linewidths of the nodes in pixels. Defaults to 1.0
    
    Label Arguments:
        
        draw_labels
            Optional boolean indicating if labels should be drawn. Defaults to
            False. 
        label_args
            Optional. Tuple of arguments to pass to the label drawing function. 
        label_kwargs
            Optional. Dictonary of keyword arguments to pass to the label 
            drawing function. 
    
    Edge Arguments:
        
        draw_edges
            Optional boolean indicating if edges should be drawn. Defaults to 
            True. 
        edges_args
            Optional. Tuple of arguments to pass to the edge drawing function. 
        edges_kwargs
            Optional. Dictonary of keyword arguments to pass to the edge 
            drawing function. 
            
    Edge Labels Arguments:
        draw_edge_labels
            Optional boolean indicating if edge labels should be drawn. Defaults to 
            False. 
        edge_label_args
            Optional. Tuple of arguments to pass to the edge label drawing function. 
        edge_label_kwargs
            Optional. Dictonary of keyword arguments to pass to the edge 
            label drawing function. 
    """
    
    def ensure_list(data, l):
        """
        Helper function that ensure that data is a list of length l. 
        """
        
        # if we are a list
        if isinstance(data, list):
            # we expect a given length
            if not len(data) == l:
                raise ValueError('Expected a list of length %s, instead got a list of length %s' % (l, len(data)))
            return data
        
        # else we make a list from the singular value
        else:
            return [data for c in range(l)]
        
    # compute the positions if omitted
    if node_pos == None:
        node_pos = nx.circular_layout(G)
    
    
    # if we want to draw the nodes
    if draw_nodes:
        # Default to the yellow color
        if node_color == None:
            node_color = 'y'
        
        # Default node size to 300
        # needs to be manually arrayified
        if node_size == None:
            node_size = 300
        
        # default node shape to 'o'
        # needs to be manually arrayified
        if node_shape == None:
            node_shape = 'o'
        
        # Default to alpha 1:
        # needs to be manually arrayified
        if node_alpha == None:
            node_alpha = 1.0
        
        # Default linewidth to 1.0
        # needs to be manually arrayified
        if node_linewidth == None:
            node_linewidth = 1.0
        
        
        # if node_alpha is a list, we need to draw each node individually
        if isinstance(node_size, list) or isinstance(node_shape, list) or isinstance(node_alpha, list) or isinstance(node_linewidth, list):
            # make everything proper
            nodes = G.nodes()
            L = len(nodes)
            
            # make everything arrays
            node_pos_a        = ensure_list(node_pos        , L)
            node_color_a      = ensure_list(node_color      , L)
            node_size_a       = ensure_list(node_size       , L)
            node_shape_a      = ensure_list(node_shape      , L)
            node_alpha_a      = ensure_list(node_alpha      , L)
            node_linewidth_a  = ensure_list(node_linewidth  , L)
            
            # and draw each node individually
            for n, c, si, sh, a, l in zip(
                nodes, 
                node_color_a, 
                node_size_a,
                node_shape_a,
                node_alpha_a,
                node_linewidth_a
            ):
                nx.draw_networkx_nodes(G, 
                    pos=node_pos, 
                    ax=ax,
                    nodes=[n], 
                    node_color=c, 
                    node_size=si,
                    node_shape=sh, 
                    node_alpha=a, 
                    node_linewidth=l
                )
            
        # we can use builtin options
        else:
            nx.draw_networkx_nodes(G, 
                pos=node_pos, 
                ax=ax,
                node_color=node_color, 
                node_size=node_size,
                node_shape=node_shape, 
                node_alpha=node_alpha, 
                node_linewidth=node_linewidth
            )
    
    # draw the labels if requested
    if draw_labels:
        
        # set default arguments
        if label_args == None:
            label_args = []
        
        if label_kwargs == None:
            label_kwargs = {}
        
        nx.draw_networkx_labels(G,
            pos=node_pos, 
            ax=ax, 
            *label_args, 
            **label_kwargs
        )
    
    # draw the edges if requested
    if draw_edges:
        
        # set default arguments
        if edges_args == None:
            edges_args = tuple()
        
        if edges_kwargs == None:
            edges_kwargs = {}
        
        nx.draw_networkx_edges(
            G,
            pos=node_pos, 
            ax=ax,
            *edges_args, 
            **edges_kwargs
        )
    
    if draw_edge_labels:
        
        # set default arguments
        if edge_label_args == None:
            edge_label_args = tuple()
        
        if edge_label_kwargs == None:
            edge_label_kwargs = {}
        
        nx.draw_networkx_edge_labels(
            G, 
            pos=node_pos, 
            ax=ax,
            *edge_label_args, 
            **edge_label_kwargs
        )
    